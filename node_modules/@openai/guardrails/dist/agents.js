"use strict";
/**
 * GuardrailAgent: Drop-in replacement for Agents SDK Agent with automatic guardrails.
 *
 * This module provides the GuardrailAgent class that acts as a factory for creating
 * Agents SDK Agent instances with guardrails automatically configured from a pipeline
 * configuration file.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.GuardrailAgent = void 0;
const content_1 = require("./utils/content");
const runtime_1 = require("./runtime");
const conversation_1 = require("./utils/conversation");
let asyncConversationStorage = null;
let fallbackConversationContext = null;
try {
    const asyncHooks = require('node:async_hooks');
    asyncConversationStorage = new asyncHooks.AsyncLocalStorage();
}
catch {
    asyncConversationStorage = null;
}
function runWithConversationContext(context, fn) {
    if (asyncConversationStorage) {
        return asyncConversationStorage.run(context, fn);
    }
    const previous = fallbackConversationContext;
    fallbackConversationContext = context;
    try {
        return fn();
    }
    finally {
        fallbackConversationContext = previous;
    }
}
function getConversationContext() {
    if (asyncConversationStorage) {
        return asyncConversationStorage.getStore() ?? null;
    }
    return fallbackConversationContext;
}
function cloneEntries(entries) {
    return entries ? entries.map((entry) => ({ ...entry })) : [];
}
function cacheConversation(conversation) {
    const context = getConversationContext();
    if (context) {
        context.cachedConversation = cloneEntries(conversation);
    }
}
async function fetchSessionItems(session) {
    if (!session) {
        return [];
    }
    if (typeof session.getItems === 'function') {
        return session.getItems();
    }
    if (typeof session.get_items === 'function') {
        return session.get_items();
    }
    return [];
}
async function loadAgentConversation() {
    const context = getConversationContext();
    if (!context) {
        return [];
    }
    if (context.cachedConversation) {
        return cloneEntries(context.cachedConversation);
    }
    const sessionItems = await fetchSessionItems(context.session);
    if (sessionItems.length > 0) {
        const normalized = (0, conversation_1.normalizeConversation)(sessionItems);
        cacheConversation(normalized);
        return cloneEntries(normalized);
    }
    if (context.fallbackConversation) {
        cacheConversation(context.fallbackConversation);
        return cloneEntries(context.fallbackConversation);
    }
    return [];
}
function entriesEqual(a, b) {
    if (!a || !b) {
        return false;
    }
    return (a.role === b.role &&
        a.type === b.type &&
        a.content === b.content &&
        a.tool_name === b.tool_name &&
        a.arguments === b.arguments &&
        a.output === b.output &&
        a.call_id === b.call_id);
}
async function ensureConversationIncludes(items) {
    if (items.length === 0) {
        return loadAgentConversation();
    }
    const base = await loadAgentConversation();
    const baseLength = base.length;
    const itemsLength = items.length;
    let needsMerge = true;
    if (baseLength >= itemsLength && itemsLength > 0) {
        needsMerge = false;
        for (let i = 0; i < itemsLength; i += 1) {
            if (!entriesEqual(base[baseLength - itemsLength + i], items[i])) {
                needsMerge = true;
                break;
            }
        }
    }
    if (!needsMerge) {
        return base;
    }
    const merged = (0, conversation_1.mergeConversationWithItems)(base, items);
    cacheConversation(merged);
    return merged;
}
function createConversationContext(baseContext, conversation) {
    const historySnapshot = cloneEntries(conversation);
    const getHistory = () => cloneEntries(historySnapshot);
    // Expose conversation_history as both a property and a method for compatibility
    const guardrailContext = {
        ...baseContext,
        conversationHistory: historySnapshot,
        getConversationHistory: getHistory,
    };
    return guardrailContext;
}
function normalizeAgentInput(input) {
    return (0, conversation_1.normalizeConversation)(input);
}
function normalizeAgentOutput(outputText) {
    if (!outputText) {
        return [];
    }
    return (0, conversation_1.normalizeConversation)([{ role: 'assistant', content: outputText }]);
}
function hasGuardrailLlm(value) {
    return (typeof value === 'object' &&
        value !== null &&
        'guardrailLlm' in value &&
        value.guardrailLlm != null);
}
function ensureGuardrailContext(providedContext, agentContext) {
    if (providedContext?.guardrailLlm) {
        return providedContext;
    }
    if (hasGuardrailLlm(agentContext)) {
        return agentContext;
    }
    const { OpenAI } = require('openai');
    const base = typeof agentContext === 'object' && agentContext !== null
        ? agentContext
        : {};
    return {
        ...base,
        guardrailLlm: new OpenAI(),
    };
}
const TEXTUAL_CONTENT_TYPES = new Set(content_1.TEXT_CONTENT_TYPES);
const MAX_CONTENT_EXTRACTION_DEPTH = 10;
/**
 * Extract text from any nested content value with optional type filtering.
 *
 * @param value Arbitrary content value (string, array, or object) to inspect.
 * @param depth Current recursion depth, used to guard against circular structures.
 * @param filterByType When true, only content parts with recognized text types are returned.
 * @returns The extracted text, or an empty string when no text is found.
 */
function extractTextFromValue(value, depth, filterByType) {
    if (depth > MAX_CONTENT_EXTRACTION_DEPTH) {
        return '';
    }
    if (typeof value === 'string') {
        return value.trim();
    }
    if (Array.isArray(value)) {
        const parts = [];
        for (const item of value) {
            const text = extractTextFromValue(item, depth + 1, filterByType);
            if (text) {
                parts.push(text);
            }
        }
        return parts.join(' ').trim();
    }
    if (value && typeof value === 'object') {
        const record = value;
        const typeValue = typeof record.type === 'string' ? record.type : null;
        const isRecognizedTextType = typeValue ? TEXTUAL_CONTENT_TYPES.has(typeValue) : false;
        if (typeof record.text === 'string') {
            if (!filterByType || isRecognizedTextType || typeValue === null) {
                return record.text.trim();
            }
        }
        const contentValue = record.content;
        // If a direct text field was skipped due to type filtering, fall back to nested content.
        if (contentValue != null) {
            const nested = extractTextFromValue(contentValue, depth + 1, filterByType);
            if (nested) {
                return nested;
            }
        }
    }
    return '';
}
/**
 * Extract text from structured content parts (e.g., the `content` field on a message).
 *
 * Only textual content-part types enumerated in TEXTUAL_CONTENT_TYPES are considered so
 * that non-text modalities (images, tools, etc.) remain ignored.
 */
function extractTextFromContentParts(content, depth = 0) {
    return extractTextFromValue(content, depth, true);
}
/**
 * Extract text from a single message entry.
 *
 * Handles strings, arrays of content parts, or message-like objects that contain a
 * `content` collection or a plain `text` field.
 */
function extractTextFromMessageEntry(entry, depth = 0) {
    if (depth > MAX_CONTENT_EXTRACTION_DEPTH) {
        return '';
    }
    if (entry == null) {
        return '';
    }
    if (typeof entry === 'string') {
        return entry.trim();
    }
    if (Array.isArray(entry)) {
        return extractTextFromContentParts(entry, depth + 1);
    }
    if (typeof entry === 'object') {
        const record = entry;
        if (record.content !== undefined) {
            const contentText = extractTextFromContentParts(record.content, depth + 1);
            if (contentText) {
                return contentText;
            }
        }
        if (typeof record.text === 'string') {
            return record.text.trim();
        }
    }
    return extractTextFromValue(entry, depth + 1, false /* allow all types when falling back */);
}
/**
 * Extract the latest user-authored text from raw agent input.
 *
 * Accepts strings, message objects, or arrays of mixed items. Arrays are scanned
 * from newest to oldest, returning the first user-role message with textual content.
 */
function extractTextFromAgentInput(input) {
    if (input == null) {
        return '';
    }
    if (typeof input === 'string') {
        return input.trim();
    }
    if (Array.isArray(input)) {
        for (let idx = input.length - 1; idx >= 0; idx -= 1) {
            const candidate = input[idx];
            if (candidate && typeof candidate === 'object') {
                const record = candidate;
                if (record.role === 'user') {
                    const text = extractTextFromMessageEntry(candidate);
                    if (text) {
                        return text;
                    }
                }
            }
            else if (typeof candidate === 'string') {
                const text = candidate.trim();
                if (text) {
                    return text;
                }
            }
        }
        return '';
    }
    if (input && typeof input === 'object') {
        const record = input;
        if (record.role === 'user') {
            const text = extractTextFromMessageEntry(record);
            if (text) {
                return text;
            }
        }
        if (record.content != null) {
            const contentText = extractTextFromContentParts(record.content);
            if (contentText) {
                return contentText;
            }
        }
        if (typeof record.text === 'string') {
            return record.text.trim();
        }
    }
    if (typeof input === 'number' ||
        typeof input === 'boolean' ||
        typeof input === 'bigint') {
        return String(input);
    }
    return '';
}
function extractLatestUserText(history) {
    for (let i = history.length - 1; i >= 0; i -= 1) {
        const entry = history[i];
        if (entry.role === 'user' && typeof entry.content === 'string' && entry.content.trim()) {
            return entry.content;
        }
    }
    return '';
}
function resolveInputText(input, history) {
    const directText = extractTextFromAgentInput(input);
    if (directText) {
        return directText;
    }
    return extractLatestUserText(history);
}
function resolveOutputText(agentOutput) {
    if (typeof agentOutput === 'string') {
        return agentOutput;
    }
    if (agentOutput && typeof agentOutput === 'object') {
        if ('response' in agentOutput) {
            return agentOutput.response || '';
        }
        if ('finalOutput' in agentOutput) {
            const finalOutput = agentOutput.finalOutput;
            return typeof finalOutput === 'string' ? finalOutput : JSON.stringify(finalOutput);
        }
    }
    return typeof agentOutput === 'object' ? JSON.stringify(agentOutput) : '';
}
let agentRunnerPatched = false;
function ensureAgentRunnerPatch() {
    if (agentRunnerPatched) {
        return;
    }
    try {
        const agentsCore = require('@openai/agents-core');
        const { Runner } = agentsCore ?? {};
        if (!Runner || typeof Runner.prototype?.run !== 'function') {
            agentRunnerPatched = true;
            return;
        }
        const originalRun = Runner.prototype.run;
        Runner.prototype.run = function patchedRun(agent, input, options) {
            const normalizedOptions = options ?? {};
            const sessionCandidate = normalizedOptions.session;
            const session = typeof sessionCandidate === 'object' && sessionCandidate !== null
                ? sessionCandidate
                : null;
            const fallbackConversation = session ? [] : (0, conversation_1.normalizeConversation)(input);
            const normalizedFallback = fallbackConversation.length > 0 ? cloneEntries(fallbackConversation) : null;
            const context = {
                session,
                fallbackConversation: normalizedFallback,
                cachedConversation: normalizedFallback,
            };
            return runWithConversationContext(context, () => originalRun.call(this, agent, input, normalizedOptions));
        };
        agentRunnerPatched = true;
    }
    catch {
        agentRunnerPatched = true;
    }
}
/**
 * Drop-in replacement for Agents SDK Agent with automatic guardrails integration.
 *
 * This class acts as a factory that creates a regular Agents SDK Agent instance
 * with guardrails automatically configured from a pipeline configuration.
 */
class GuardrailAgent {
    static async create(config, name, instructions, agentKwargs = {}, raiseGuardrailErrors = false) {
        ensureAgentRunnerPatch();
        try {
            const agentsModule = await Promise.resolve().then(() => __importStar(require('@openai/agents')));
            const { Agent } = agentsModule;
            const pipeline = (await (0, runtime_1.loadPipelineBundles)(config));
            // Extract any user-provided guardrails from agentKwargs
            const userInputGuardrails = agentKwargs.inputGuardrails;
            const userOutputGuardrails = agentKwargs.outputGuardrails;
            // Remove them from agentKwargs to avoid duplication
            const filteredAgentKwargs = { ...agentKwargs };
            delete filteredAgentKwargs.inputGuardrails;
            delete filteredAgentKwargs.outputGuardrails;
            // Create agent-level INPUT guardrails from config
            const inputGuardrails = [];
            if (pipeline.pre_flight) {
                const preFlightGuardrails = await createInputGuardrailsFromStage('pre_flight', pipeline.pre_flight, undefined, raiseGuardrailErrors);
                inputGuardrails.push(...preFlightGuardrails);
            }
            if (pipeline.input) {
                const inputStageGuardrails = await createInputGuardrailsFromStage('input', pipeline.input, undefined, raiseGuardrailErrors);
                inputGuardrails.push(...inputStageGuardrails);
            }
            // Merge with user-provided input guardrails (config ones run first, then user ones)
            if (userInputGuardrails && Array.isArray(userInputGuardrails)) {
                inputGuardrails.push(...userInputGuardrails);
            }
            // Create agent-level OUTPUT guardrails from config
            const outputGuardrails = [];
            if (pipeline.output) {
                const outputStageGuardrails = await createOutputGuardrailsFromStage('output', pipeline.output, undefined, raiseGuardrailErrors);
                outputGuardrails.push(...outputStageGuardrails);
            }
            // Merge with user-provided output guardrails (config ones run first, then user ones)
            if (userOutputGuardrails && Array.isArray(userOutputGuardrails)) {
                outputGuardrails.push(...userOutputGuardrails);
            }
            return new Agent({
                name,
                instructions,
                inputGuardrails,
                outputGuardrails,
                ...filteredAgentKwargs,
            });
        }
        catch (error) {
            if (error instanceof Error && error.message.includes('Cannot resolve module')) {
                throw new Error('The @openai/agents package is required to use GuardrailAgent. ' +
                    'Please install it with: npm install @openai/agents');
            }
            throw error;
        }
    }
}
exports.GuardrailAgent = GuardrailAgent;
async function createInputGuardrailsFromStage(stageName, stageConfig, context, raiseGuardrailErrors = false) {
    const guardrails = await (0, runtime_1.instantiateGuardrails)(stageConfig);
    // Optimization: Check if any guardrail in this stage needs conversation history
    const needsConversationHistory = guardrails.some((g) => g.definition.metadata?.usesConversationHistory);
    return guardrails.map((guardrail) => ({
        name: `${stageName}: ${guardrail.definition.name || 'Unknown Guardrail'}`,
        execute: async (args) => {
            const { input, context: agentContext } = args;
            try {
                const guardContext = ensureGuardrailContext(context, agentContext);
                const normalizedItems = normalizeAgentInput(input);
                let ctxWithConversation;
                let conversationHistory;
                // Only load conversation history if at least one guardrail in this stage needs it
                if (needsConversationHistory) {
                    conversationHistory = await ensureConversationIncludes(normalizedItems);
                    ctxWithConversation = createConversationContext(guardContext, conversationHistory);
                }
                else {
                    conversationHistory = normalizedItems;
                    ctxWithConversation = guardContext;
                }
                const inputText = resolveInputText(input, conversationHistory);
                const result = await guardrail.run(ctxWithConversation, inputText);
                if (raiseGuardrailErrors && result.executionFailed) {
                    throw result.originalException;
                }
                return {
                    outputInfo: {
                        ...(result.info || {}),
                        input: inputText,
                    },
                    tripwireTriggered: result.tripwireTriggered || false,
                };
            }
            catch (error) {
                if (raiseGuardrailErrors) {
                    throw error;
                }
                return {
                    outputInfo: {
                        error: error instanceof Error ? error.message : String(error),
                        guardrail_name: guardrail.definition.name || 'unknown',
                        input: typeof input === 'string' ? input : JSON.stringify(input),
                    },
                    tripwireTriggered: false,
                };
            }
        },
    }));
}
async function createOutputGuardrailsFromStage(stageName, stageConfig, context, raiseGuardrailErrors = false) {
    const guardrails = await (0, runtime_1.instantiateGuardrails)(stageConfig);
    // Optimization: Check if any guardrail in this stage needs conversation history
    const needsConversationHistory = guardrails.some((g) => g.definition.metadata?.usesConversationHistory);
    return guardrails.map((guardrail) => ({
        name: `${stageName}: ${guardrail.definition.name || 'Unknown Guardrail'}`,
        execute: async (args) => {
            const { agentOutput, context: agentContext } = args;
            try {
                const guardContext = ensureGuardrailContext(context, agentContext);
                const outputText = resolveOutputText(agentOutput);
                const normalizedItems = normalizeAgentOutput(outputText);
                let ctxWithConversation;
                // Only load conversation history if at least one guardrail in this stage needs it
                if (needsConversationHistory) {
                    const conversationHistory = await ensureConversationIncludes(normalizedItems);
                    ctxWithConversation = createConversationContext(guardContext, conversationHistory);
                }
                else {
                    ctxWithConversation = guardContext;
                }
                const result = await guardrail.run(ctxWithConversation, outputText);
                if (raiseGuardrailErrors && result.executionFailed) {
                    throw result.originalException;
                }
                return {
                    outputInfo: {
                        ...(result.info || {}),
                        input: outputText,
                    },
                    tripwireTriggered: result.tripwireTriggered || false,
                };
            }
            catch (error) {
                if (raiseGuardrailErrors) {
                    throw error;
                }
                return {
                    outputInfo: {
                        error: error instanceof Error ? error.message : String(error),
                        guardrail_name: guardrail.definition.name || 'unknown',
                        input: typeof agentOutput === 'string' ? agentOutput : JSON.stringify(agentOutput, null, 2),
                    },
                    tripwireTriggered: false,
                };
            }
        },
    }));
}
//# sourceMappingURL=agents.js.map