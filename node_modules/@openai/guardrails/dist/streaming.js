"use strict";
/**
 * Streaming functionality for guardrails integration.
 *
 * This module contains streaming-related logic for handling LLM responses
 * with periodic guardrail checks.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamingMixin = void 0;
const exceptions_1 = require("./exceptions");
const conversation_1 = require("./utils/conversation");
/**
 * Mixin providing streaming functionality for guardrails clients.
 */
class StreamingMixin {
    /**
     * Stream with periodic guardrail checks (async).
     */
    async *streamWithGuardrails(llmStream, preflightResults, inputResults, conversationHistory, checkInterval = 100, suppressTripwire = false) {
        let accumulatedText = '';
        let chunkCount = 0;
        const baseHistory = conversationHistory ? conversationHistory.map((entry) => ({ ...entry })) : [];
        for await (const chunk of llmStream) {
            const chunkText = this.extractResponseText(chunk);
            if (chunkText) {
                accumulatedText += chunkText;
                chunkCount += 1;
                if (chunkCount % checkInterval === 0) {
                    try {
                        const history = (0, conversation_1.mergeConversationWithItems)(baseHistory, [
                            { role: 'assistant', content: accumulatedText },
                        ]);
                        await this.runStageGuardrails('output', accumulatedText, history, suppressTripwire);
                    }
                    catch (error) {
                        if (error instanceof exceptions_1.GuardrailTripwireTriggered) {
                            const finalResponse = this.createGuardrailsResponse(chunk, preflightResults, inputResults, [error.guardrailResult]);
                            yield finalResponse;
                            throw error;
                        }
                        throw error;
                    }
                }
            }
            const response = this.createGuardrailsResponse(chunk, preflightResults, inputResults, []);
            yield response;
        }
        if (!suppressTripwire && accumulatedText) {
            try {
                const history = (0, conversation_1.mergeConversationWithItems)(baseHistory, [
                    { role: 'assistant', content: accumulatedText },
                ]);
                const finalOutputResults = await this.runStageGuardrails('output', accumulatedText, history, suppressTripwire);
                const finalResponse = this.createGuardrailsResponse({ type: 'final', accumulated_text: accumulatedText }, preflightResults, inputResults, finalOutputResults);
                yield finalResponse;
            }
            catch (error) {
                if (error instanceof exceptions_1.GuardrailTripwireTriggered) {
                    const finalResponse = this.createGuardrailsResponse({ type: 'final', accumulated_text: accumulatedText }, preflightResults, inputResults, [error.guardrailResult]);
                    yield finalResponse;
                    throw error;
                }
                throw error;
            }
        }
    }
    /**
     * Stream with guardrails (sync wrapper for compatibility).
     */
    static streamWithGuardrailsSync(client, llmStream, preflightResults, inputResults, conversationHistory, suppressTripwire = false) {
        const streamingMixin = new StreamingMixin();
        return streamingMixin.streamWithGuardrails.call(client, llmStream, preflightResults, inputResults, conversationHistory, 100, suppressTripwire);
    }
}
exports.StreamingMixin = StreamingMixin;
//# sourceMappingURL=streaming.js.map