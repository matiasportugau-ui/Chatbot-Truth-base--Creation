"use strict";
/**
 * Content processing utilities for guardrails.
 *
 * Provides centralized logic for content type detection, text extraction,
 * and message filtering for guardrail processing.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContentUtils = exports.TEXT_CONTENT_TYPES = void 0;
exports.TEXT_CONTENT_TYPES = ['input_text', 'text', 'output_text', 'summary_text'];
const TEXT_CONTENT_TYPES_SET = new Set(exports.TEXT_CONTENT_TYPES);
class ContentUtils {
    /**
     * Check if a content part is text-based.
     */
    static isText(part) {
        return typeof part.type === 'string' && TEXT_CONTENT_TYPES_SET.has(part.type);
    }
    /**
     * Extract text from a message.
     */
    static extractTextFromMessage(message) {
        if (typeof message.content === 'string') {
            return message.content.trim();
        }
        if (Array.isArray(message.content)) {
            return message.content
                .filter(part => this.isText(part))
                .map(part => part.text)
                .join(' ')
                .trim();
        }
        return '';
    }
    /**
     * Filter messages to text-only (for guardrails).
     *
     * Guardrails only work with text content, so this filters out
     * messages that don't contain any text parts.
     */
    static filterToTextOnly(messages) {
        return messages
            .filter(msg => this.hasTextContent(msg))
            .map(msg => ({
            role: msg.role,
            content: msg.content
        }));
    }
    /**
     * Check if a message has text content.
     */
    static hasTextContent(message) {
        if (typeof message.content === 'string') {
            return true;
        }
        if (Array.isArray(message.content)) {
            return message.content.some(part => this.isText(part));
        }
        return false;
    }
}
exports.ContentUtils = ContentUtils;
//# sourceMappingURL=content.js.map