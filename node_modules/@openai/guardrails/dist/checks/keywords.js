"use strict";
/**
 * Keywords-based content filtering guardrail.
 *
 * This guardrail checks if specified keywords appear in the input text
 * and can be configured to trigger tripwires based on keyword matches.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.keywordsCheck = exports.KeywordsContext = exports.KeywordsConfigRequired = exports.KeywordsConfig = void 0;
const zod_1 = require("zod");
const registry_1 = require("../registry");
/**
 * Configuration schema for the keywords guardrail.
 */
exports.KeywordsConfig = zod_1.z.object({
    /** List of keywords to check for */
    keywords: zod_1.z.array(zod_1.z.string()).min(1),
});
// Schema for registry registration (without optional properties)
exports.KeywordsConfigRequired = exports.KeywordsConfig;
/**
 * Context requirements for the keywords guardrail.
 */
exports.KeywordsContext = zod_1.z.object({});
/**
 * Keywords-based content filtering guardrail.
 *
 * Checks if any of the configured keywords appear in the input text.
 * Can be configured to trigger tripwires on matches or just report them.
 *
 * @param ctx Runtime context (unused for this guardrail)
 * @param text Input text to check
 * @param config Configuration specifying keywords and behavior
 * @returns GuardrailResult indicating if tripwire was triggered
 */
const WORD_CHAR_CLASS = '[\\p{L}\\p{N}_]';
const isWordChar = (() => {
    const wordCharRegex = new RegExp(WORD_CHAR_CLASS, 'u');
    return (char) => {
        if (!char)
            return false;
        return wordCharRegex.test(char);
    };
})();
const keywordsCheck = (ctx, text, config) => {
    // Handle the case where config might be wrapped in another object
    const actualConfig = config.config || config;
    const { keywords } = actualConfig;
    // Sanitize keywords by stripping trailing punctuation
    const sanitizedKeywords = keywords.map((k) => k.replace(/[.,!?;:]+$/, ''));
    const keywordEntries = sanitizedKeywords
        .map((sanitized) => ({
        sanitized,
        escaped: sanitized.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'),
    }))
        .filter(({ sanitized }) => sanitized.length > 0);
    if (keywordEntries.length === 0) {
        return {
            tripwireTriggered: false,
            info: {
                matchedKeywords: [],
                originalKeywords: keywords,
                sanitizedKeywords,
                totalKeywords: keywords.length,
                textLength: text.length,
            },
        };
    }
    // Apply unicode-aware word boundaries per keyword so tokens that start/end with punctuation still match.
    const keywordPatterns = keywordEntries.map(({ sanitized, escaped }) => {
        const keywordChars = Array.from(sanitized);
        const firstChar = keywordChars[0];
        const lastChar = keywordChars[keywordChars.length - 1];
        const needsLeftBoundary = isWordChar(firstChar);
        const needsRightBoundary = isWordChar(lastChar);
        const leftBoundary = needsLeftBoundary ? `(?<!${WORD_CHAR_CLASS})` : '';
        const rightBoundary = needsRightBoundary ? `(?!${WORD_CHAR_CLASS})` : '';
        return `${leftBoundary}${escaped}${rightBoundary}`;
    });
    const patternText = `(?:${keywordPatterns.join('|')})`;
    const pattern = new RegExp(patternText, 'giu'); // case-insensitive, global, unicode aware
    const matches = [];
    let match;
    const seen = new Set();
    // Find all matches and collect unique ones (case-insensitive)
    while ((match = pattern.exec(text)) !== null) {
        const matchedText = match[0];
        if (!seen.has(matchedText.toLowerCase())) {
            matches.push(matchedText);
            seen.add(matchedText.toLowerCase());
        }
    }
    const tripwireTriggered = matches.length > 0;
    return {
        tripwireTriggered,
        info: {
            matchedKeywords: matches,
            originalKeywords: keywords,
            sanitizedKeywords: sanitizedKeywords,
            totalKeywords: keywords.length,
            textLength: text.length,
        },
    };
};
exports.keywordsCheck = keywordsCheck;
// Auto-register this guardrail with the default registry
registry_1.defaultSpecRegistry.register('Keyword Filter', exports.keywordsCheck, 'Checks for specified keywords in text', 'text/plain', exports.KeywordsConfigRequired, exports.KeywordsContext, { engine: 'regex' });
//# sourceMappingURL=keywords.js.map