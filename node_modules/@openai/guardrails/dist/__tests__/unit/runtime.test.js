"use strict";
/**
 * Unit tests for the runtime module.
 *
 * This module tests the core runtime functionality including:
 * - Configuration bundle loading
 * - Guardrail instantiation
 * - Guardrail execution
 * - Error handling
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const vitest_1 = require("vitest");
const runtime_1 = require("../../runtime");
const registry_1 = require("../../registry");
const zod_1 = require("zod");
const openai_1 = require("openai");
const path_1 = __importDefault(require("path"));
const os_1 = __importDefault(require("os"));
const fs_1 = require("fs");
// Mock OpenAI module
vitest_1.vi.mock('openai', () => ({
    OpenAI: class MockOpenAI {
    },
}));
// Mock context
const context = {
    guardrailLlm: new openai_1.OpenAI({ apiKey: 'test-key' }),
};
(0, vitest_1.describe)('Runtime Module', () => {
    (0, vitest_1.describe)('loadConfigBundle', () => {
        (0, vitest_1.it)('should load valid configuration bundle', () => {
            const bundleJson = JSON.stringify({
                version: 1,
                stageName: 'test',
                guardrails: [
                    {
                        name: 'test_guard',
                        config: { threshold: 10 },
                    },
                ],
            });
            const bundle = (0, runtime_1.loadConfigBundle)(bundleJson);
            (0, vitest_1.expect)(bundle.version).toBe(1);
            (0, vitest_1.expect)(bundle.stageName).toBe('test');
            (0, vitest_1.expect)(bundle.guardrails).toHaveLength(1);
        });
        (0, vitest_1.it)('should handle invalid JSON gracefully', () => {
            (0, vitest_1.expect)(() => (0, runtime_1.loadConfigBundle)('invalid json')).toThrow();
        });
        (0, vitest_1.it)('should validate required fields', () => {
            const invalidBundle = JSON.stringify({
                stageName: 'test',
                guardrails: [
                    {
                        name: 'test_guard',
                        // Missing config
                    },
                ],
            });
            (0, vitest_1.expect)(() => (0, runtime_1.loadConfigBundle)(invalidBundle)).toThrow();
        });
    });
    (0, vitest_1.beforeEach)(() => {
        vitest_1.vi.clearAllMocks();
    });
    (0, vitest_1.describe)('GuardrailConfig', () => {
        (0, vitest_1.it)('should create config with required fields', () => {
            const config = {
                name: 'test_guard',
                config: { threshold: 10 },
            };
            (0, vitest_1.expect)(config.name).toBe('test_guard');
            (0, vitest_1.expect)(config.config.threshold).toBe(10);
        });
    });
    (0, vitest_1.describe)('GuardrailBundle', () => {
        (0, vitest_1.it)('should create bundle with required fields', () => {
            const bundle = {
                stageName: 'test',
                guardrails: [],
            };
            (0, vitest_1.expect)(bundle.stageName).toBe('test');
            (0, vitest_1.expect)(bundle.guardrails).toHaveLength(0);
        });
        (0, vitest_1.it)('should validate required fields', () => {
            (0, vitest_1.expect)(() => (0, runtime_1.loadConfigBundle)('{"version": 1}')).toThrow();
        });
    });
    (0, vitest_1.describe)('Guardrail Execution', () => {
        const TEST_GUARD = 'runtime_test_guard';
        const configSchema = zod_1.z.object({
            threshold: zod_1.z.number(),
            shouldTrip: zod_1.z.boolean().optional(),
        });
        let guardrailCheck;
        (0, vitest_1.beforeEach)(() => {
            guardrailCheck = vitest_1.vi.fn().mockImplementation((_ctx, data, cfg) => ({
                tripwireTriggered: Boolean(cfg.shouldTrip),
                info: {
                    threshold: cfg.threshold,
                    payload: data,
                },
            }));
            registry_1.defaultSpecRegistry.register(TEST_GUARD, guardrailCheck, 'Runtime test guard', 'text/plain', configSchema, zod_1.z.object({}), { name: 'Runtime Test Guard' });
        });
        (0, vitest_1.afterEach)(() => {
            registry_1.defaultSpecRegistry.remove(TEST_GUARD);
        });
        const createBundle = (config = { threshold: 5 }) => ({
            guardrails: [
                {
                    name: TEST_GUARD,
                    config,
                },
            ],
        });
        (0, vitest_1.it)('should instantiate guardrails with validated config', async () => {
            const bundle = createBundle({ threshold: 2 });
            const guardrails = await (0, runtime_1.instantiateGuardrails)(bundle);
            (0, vitest_1.expect)(guardrails).toHaveLength(1);
            (0, vitest_1.expect)(guardrails[0].config).toEqual({ threshold: 2 });
            (0, vitest_1.expect)(typeof guardrails[0].run).toBe('function');
        });
        (0, vitest_1.it)('should run guardrails and return aggregated results', async () => {
            const bundle = createBundle({ threshold: 7 });
            const results = await (0, runtime_1.runGuardrails)('payload', bundle, context);
            (0, vitest_1.expect)(results).toHaveLength(1);
            (0, vitest_1.expect)(results[0].tripwireTriggered).toBe(false);
            (0, vitest_1.expect)(results[0].info).toMatchObject({
                threshold: 7,
            });
            (0, vitest_1.expect)(guardrailCheck).toHaveBeenCalledWith(context, 'payload', { threshold: 7 });
        });
        (0, vitest_1.it)('should surface execution failures without raising when raiseGuardrailErrors=false', async () => {
            guardrailCheck = vitest_1.vi.fn().mockRejectedValue(new Error('boom'));
            registry_1.defaultSpecRegistry.remove(TEST_GUARD);
            registry_1.defaultSpecRegistry.register(TEST_GUARD, guardrailCheck, 'Runtime test guard', 'text/plain', configSchema, zod_1.z.object({}), { name: 'Runtime Test Guard' });
            const bundle = createBundle({ threshold: 1 });
            const results = await (0, runtime_1.runGuardrails)('payload', bundle, context);
            (0, vitest_1.expect)(results).toHaveLength(1);
            (0, vitest_1.expect)(results[0].executionFailed).toBe(true);
            (0, vitest_1.expect)(results[0].tripwireTriggered).toBe(false);
            (0, vitest_1.expect)(results[0].info?.guardrailName).toBe('Runtime Test Guard');
        });
        (0, vitest_1.it)('should rethrow the first execution failure when raiseGuardrailErrors=true', async () => {
            guardrailCheck = vitest_1.vi.fn().mockRejectedValue(new Error('explode'));
            registry_1.defaultSpecRegistry.remove(TEST_GUARD);
            registry_1.defaultSpecRegistry.register(TEST_GUARD, guardrailCheck, 'Runtime test guard', 'text/plain', configSchema, zod_1.z.object({}), { name: 'Runtime Test Guard' });
            const bundle = createBundle({ threshold: 3 });
            await (0, vitest_1.expect)((0, runtime_1.runGuardrails)('payload', bundle, context, true)).rejects.toThrow('explode');
        });
        (0, vitest_1.it)('should throw when a guardrail tripwire is triggered via checkPlainText', async () => {
            guardrailCheck = vitest_1.vi.fn().mockResolvedValue({
                tripwireTriggered: true,
                info: { reason: 'bad' },
            });
            registry_1.defaultSpecRegistry.remove(TEST_GUARD);
            registry_1.defaultSpecRegistry.register(TEST_GUARD, guardrailCheck, 'Runtime test guard', 'text/plain', configSchema, zod_1.z.object({}), { name: 'Runtime Test Guard' });
            const bundle = createBundle({ threshold: 4, shouldTrip: true });
            await (0, vitest_1.expect)((0, runtime_1.checkPlainText)('payload', bundle, context)).rejects.toThrow(/Content validation failed: 1 security violation/);
            try {
                await (0, runtime_1.checkPlainText)('payload', bundle, context);
            }
            catch (error) {
                const err = error;
                (0, vitest_1.expect)(Array.isArray(err.guardrailResults)).toBe(true);
                (0, vitest_1.expect)(err.guardrailResults).toHaveLength(1);
                (0, vitest_1.expect)(err.guardrailResults[0].info?.reason).toBe('bad');
            }
        });
        (0, vitest_1.it)('should throw if a guardrail name cannot be found in the registry', async () => {
            const bundle = {
                guardrails: [
                    {
                        name: 'missing_guardrail',
                        config: {},
                    },
                ],
            };
            await (0, vitest_1.expect)((0, runtime_1.instantiateGuardrails)(bundle)).rejects.toThrow("Guardrail 'missing_guardrail' not found in registry");
        });
        (0, vitest_1.it)('should surface schema validation errors during guardrail instantiation', async () => {
            const bundle = createBundle({ threshold: 'bad' });
            await (0, vitest_1.expect)((0, runtime_1.instantiateGuardrails)(bundle)).rejects.toThrow(/Failed to instantiate guardrail 'runtime_test_guard'/);
        });
    });
    (0, vitest_1.describe)('loadPipelineBundles', () => {
        (0, vitest_1.it)('should parse JSON string configs', async () => {
            const config = { input: { guardrails: [] } };
            const result = await (0, runtime_1.loadPipelineBundles)(JSON.stringify(config));
            (0, vitest_1.expect)(result).toEqual(config);
        });
        (0, vitest_1.it)('should load pipeline configs from disk when given a file path', async () => {
            const tempDir = await fs_1.promises.mkdtemp(path_1.default.join(os_1.default.tmpdir(), 'runtime-tests-'));
            const filePath = path_1.default.join(tempDir, 'pipeline.json');
            const config = { output: { guardrails: [] } };
            await fs_1.promises.writeFile(filePath, JSON.stringify(config), 'utf-8');
            const result = await (0, runtime_1.loadPipelineBundles)(filePath);
            (0, vitest_1.expect)(result).toEqual(config);
            await fs_1.promises.rm(tempDir, { recursive: true, force: true });
        });
        (0, vitest_1.it)('should return config objects unchanged', async () => {
            const config = { pre_flight: { guardrails: [] } };
            const result = await (0, runtime_1.loadPipelineBundles)(config);
            (0, vitest_1.expect)(result).toBe(config);
        });
    });
});
//# sourceMappingURL=runtime.test.js.map