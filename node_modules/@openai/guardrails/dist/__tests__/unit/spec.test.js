"use strict";
/**
 * Unit tests for the spec module.
 *
 * This module tests the guardrail specification functionality including:
 * - GuardrailSpec creation and properties
 * - Metadata handling
 * - Schema generation
 * - Validation
 */
Object.defineProperty(exports, "__esModule", { value: true });
const vitest_1 = require("vitest");
const spec_1 = require("../../spec");
const zod_1 = require("zod");
// Mock check function for testing
const mockCheck = (ctx, data) => ({
    tripwireTriggered: false,
    info: {
        sample_text: data,
    },
});
// Test config schema
const TestConfigSchema = zod_1.z.object({
    threshold: zod_1.z.number(),
});
// Test context schema
const TestContextSchema = zod_1.z.object({
    user: zod_1.z.string(),
});
(0, vitest_1.describe)('Spec Module', () => {
    (0, vitest_1.describe)('GuardrailSpec', () => {
        (0, vitest_1.it)('should create spec with all properties', () => {
            const metadata = {
                engine: 'typescript',
            };
            const spec = new spec_1.GuardrailSpec('test_spec', 'Test specification', 'text/plain', TestConfigSchema, mockCheck, TestContextSchema, metadata);
            (0, vitest_1.expect)(spec.name).toBe('test_spec');
            (0, vitest_1.expect)(spec.description).toBe('Test specification');
            (0, vitest_1.expect)(spec.mediaType).toBe('text/plain');
            (0, vitest_1.expect)(spec.checkFn).toBe(mockCheck);
            (0, vitest_1.expect)(spec.configSchema).toBe(TestConfigSchema);
            (0, vitest_1.expect)(spec.ctxRequirements).toBe(TestContextSchema);
            (0, vitest_1.expect)(spec.metadata?.engine).toBe('typescript');
        });
        (0, vitest_1.it)('should generate JSON schema from config schema', () => {
            const spec = new spec_1.GuardrailSpec('schema_spec', 'Schema specification', 'text/plain', TestConfigSchema, mockCheck, TestContextSchema);
            const schema = spec.schema();
            (0, vitest_1.expect)(schema).toBeDefined();
            // The schema() method returns the Zod schema definition, not JSON schema
            (0, vitest_1.expect)(schema).toBe(TestConfigSchema._def);
        });
        (0, vitest_1.it)('should handle spec without config schema', () => {
            const emptySchema = zod_1.z.object({});
            const spec = new spec_1.GuardrailSpec('no_config_spec', 'No config specification', 'text/plain', emptySchema, // Empty config schema
            mockCheck, TestContextSchema);
            (0, vitest_1.expect)(spec.configSchema).toBeDefined();
            const schema = spec.schema();
            (0, vitest_1.expect)(schema).toBeDefined();
            // The schema() method returns the Zod schema definition
            (0, vitest_1.expect)(schema).toBe(emptySchema._def);
        });
        (0, vitest_1.it)('should handle spec without context requirements', () => {
            const spec = new spec_1.GuardrailSpec('no_context_spec', 'No context specification', 'text/plain', TestConfigSchema, mockCheck, zod_1.z.object({}));
            (0, vitest_1.expect)(spec.ctxRequirements).toBeDefined();
        });
        (0, vitest_1.it)('should handle spec without metadata', () => {
            const spec = new spec_1.GuardrailSpec('no_metadata_spec', 'No metadata specification', 'text/plain', TestConfigSchema, mockCheck, TestContextSchema);
            (0, vitest_1.expect)(spec.metadata).toBeUndefined();
        });
        (0, vitest_1.it)('should instantiate guardrail from spec', () => {
            const spec = new spec_1.GuardrailSpec('instantiate_spec', 'Instantiate specification', 'text/plain', TestConfigSchema, mockCheck, TestContextSchema);
            const guardrail = spec.instantiate({ threshold: 5 });
            (0, vitest_1.expect)(guardrail.definition).toBe(spec);
            (0, vitest_1.expect)(guardrail.config).toEqual({ threshold: 5 });
        });
        (0, vitest_1.it)('should run instantiated guardrail', async () => {
            const spec = new spec_1.GuardrailSpec('run_spec', 'Run specification', 'text/plain', TestConfigSchema, mockCheck, TestContextSchema);
            const guardrail = spec.instantiate({ threshold: 5 });
            const result = await guardrail.run({ user: 'test' }, 'Hello world');
            (0, vitest_1.expect)(result.tripwireTriggered).toBe(false);
        });
    });
    (0, vitest_1.describe)('GuardrailSpecMetadata', () => {
        (0, vitest_1.it)('should create metadata with engine', () => {
            const metadata = {
                engine: 'typescript',
            };
            (0, vitest_1.expect)(metadata.engine).toBe('typescript');
        });
        (0, vitest_1.it)('should allow extra fields', () => {
            const metadata = {
                engine: 'regex',
                custom: 123,
                version: '1.0.0',
            };
            (0, vitest_1.expect)(metadata.engine).toBe('regex');
            (0, vitest_1.expect)(metadata.custom).toBe(123);
            (0, vitest_1.expect)(metadata.version).toBe('1.0.0');
        });
        (0, vitest_1.it)('should handle empty metadata', () => {
            const metadata = {};
            (0, vitest_1.expect)(metadata.engine).toBeUndefined();
        });
    });
    (0, vitest_1.describe)('GuardrailSpec instantiation', () => {
        (0, vitest_1.it)('should create spec with minimal parameters', () => {
            const spec = new spec_1.GuardrailSpec('minimal_spec', 'Minimal specification', 'text/plain', zod_1.z.object({}), mockCheck, zod_1.z.object({}));
            (0, vitest_1.expect)(spec.name).toBe('minimal_spec');
            (0, vitest_1.expect)(spec.description).toBe('Minimal specification');
            (0, vitest_1.expect)(spec.mediaType).toBe('text/plain');
        });
        (0, vitest_1.it)('should create spec with complex config schema', () => {
            const complexSchema = zod_1.z.object({
                threshold: zod_1.z.number(),
                enabled: zod_1.z.boolean(),
                patterns: zod_1.z.array(zod_1.z.string()),
            });
            const spec = new spec_1.GuardrailSpec('complex_spec', 'Complex specification', 'text/plain', complexSchema, mockCheck, zod_1.z.object({}));
            (0, vitest_1.expect)(spec.configSchema).toBe(complexSchema);
        });
        (0, vitest_1.it)('should create spec with complex context schema', () => {
            const complexContext = zod_1.z.object({
                user: zod_1.z.string(),
                permissions: zod_1.z.array(zod_1.z.string()),
                settings: zod_1.z.record(zod_1.z.unknown()),
            });
            const spec = new spec_1.GuardrailSpec('complex_context_spec', 'Complex context specification', 'text/plain', zod_1.z.object({}), mockCheck, complexContext);
            (0, vitest_1.expect)(spec.ctxRequirements).toBe(complexContext);
        });
        (0, vitest_1.it)('should handle spec with all optional parameters', () => {
            const spec = new spec_1.GuardrailSpec('full_spec', 'Full specification', 'text/plain', TestConfigSchema, mockCheck, TestContextSchema, { engine: 'typescript', version: '1.0.0' });
            (0, vitest_1.expect)(spec.metadata?.engine).toBe('typescript');
            (0, vitest_1.expect)(spec.metadata?.version).toBe('1.0.0');
        });
    });
    (0, vitest_1.describe)('GuardrailSpec validation', () => {
        (0, vitest_1.it)('should validate required name', () => {
            (0, vitest_1.expect)(() => new spec_1.GuardrailSpec('', 'Test description', 'text/plain', zod_1.z.object({}), mockCheck, zod_1.z.object({}))).not.toThrow();
        });
        (0, vitest_1.it)('should validate required description', () => {
            (0, vitest_1.expect)(() => new spec_1.GuardrailSpec('test_name', '', 'text/plain', zod_1.z.object({}), mockCheck, zod_1.z.object({}))).not.toThrow();
        });
        (0, vitest_1.it)('should validate required mediaType', () => {
            (0, vitest_1.expect)(() => new spec_1.GuardrailSpec('test_name', 'Test description', '', zod_1.z.object({}), mockCheck, zod_1.z.object({}))).not.toThrow();
        });
        (0, vitest_1.it)('should validate required checkFn', () => {
            (0, vitest_1.expect)(() => new spec_1.GuardrailSpec('test_name', 'Test description', 'text/plain', zod_1.z.object({}), undefined, zod_1.z.object({}))).not.toThrow();
        });
    });
});
//# sourceMappingURL=spec.test.js.map