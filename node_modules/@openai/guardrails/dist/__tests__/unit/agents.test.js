"use strict";
/**
 * Unit tests for GuardrailAgent functionality.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const vitest_1 = require("vitest");
const agents_1 = require("../../agents");
const zod_1 = require("zod");
// Mock the @openai/agents module
vitest_1.vi.mock('@openai/agents', () => ({
    Agent: vitest_1.vi.fn().mockImplementation((config) => ({
        name: config.name,
        instructions: config.instructions,
        inputGuardrails: config.inputGuardrails || [],
        outputGuardrails: config.outputGuardrails || [],
        ...config,
    })),
}));
// Mock the runtime functions
vitest_1.vi.mock('../../runtime', () => ({
    loadPipelineBundles: vitest_1.vi.fn((config) => config),
    instantiateGuardrails: vitest_1.vi.fn(() => Promise.resolve([
        {
            definition: {
                name: 'Keywords',
                description: 'Test guardrail',
                mediaType: 'text/plain',
                configSchema: zod_1.z.object({}),
                checkFn: vitest_1.vi.fn(),
                contextSchema: zod_1.z.object({}),
                metadata: {},
            },
            config: {},
            run: vitest_1.vi.fn().mockResolvedValue({
                tripwireTriggered: false,
                info: { guardrail_name: 'Keywords', preview: 'test input' },
            }),
        },
    ])),
    runGuardrails: vitest_1.vi.fn(() => Promise.resolve([])),
}));
// Mock the registry
vitest_1.vi.mock('../../registry', () => ({
    defaultSpecRegistry: {
        get: vitest_1.vi.fn(() => ({
            instantiate: vitest_1.vi.fn(() => ({ run: vitest_1.vi.fn() })),
        })),
    },
}));
(0, vitest_1.describe)('GuardrailAgent', () => {
    (0, vitest_1.beforeEach)(() => {
        vitest_1.vi.clearAllMocks();
    });
    (0, vitest_1.describe)('create', () => {
        (0, vitest_1.it)('should create an agent with input guardrails from pre_flight and input stages', async () => {
            const config = {
                version: 1,
                pre_flight: {
                    version: 1,
                    guardrails: [{ name: 'Moderation', config: {} }],
                },
                input: {
                    version: 1,
                    guardrails: [{ name: 'Keywords', config: {} }],
                },
            };
            const agent = (await agents_1.GuardrailAgent.create(config, 'Test Agent', 'Test instructions'));
            (0, vitest_1.expect)(agent.name).toBe('Test Agent');
            (0, vitest_1.expect)(agent.instructions).toBe('Test instructions');
            (0, vitest_1.expect)(agent.inputGuardrails).toHaveLength(2); // pre_flight + input
            (0, vitest_1.expect)(agent.outputGuardrails).toHaveLength(0);
        });
        (0, vitest_1.it)('should create an agent with output guardrails from output stage', async () => {
            const config = {
                version: 1,
                output: {
                    version: 1,
                    guardrails: [{ name: 'URL Filter', config: {} }],
                },
            };
            const agent = (await agents_1.GuardrailAgent.create(config, 'Test Agent', 'Test instructions'));
            (0, vitest_1.expect)(agent.name).toBe('Test Agent');
            (0, vitest_1.expect)(agent.instructions).toBe('Test instructions');
            (0, vitest_1.expect)(agent.inputGuardrails).toHaveLength(0);
            (0, vitest_1.expect)(agent.outputGuardrails).toHaveLength(1);
        });
        (0, vitest_1.it)('should create an agent with both input and output guardrails', async () => {
            const config = {
                version: 1,
                pre_flight: {
                    version: 1,
                    guardrails: [{ name: 'Moderation', config: {} }],
                },
                input: {
                    version: 1,
                    guardrails: [{ name: 'Keywords', config: {} }],
                },
                output: {
                    version: 1,
                    guardrails: [{ name: 'URL Filter', config: {} }],
                },
            };
            const agent = (await agents_1.GuardrailAgent.create(config, 'Test Agent', 'Test instructions'));
            (0, vitest_1.expect)(agent.name).toBe('Test Agent');
            (0, vitest_1.expect)(agent.instructions).toBe('Test instructions');
            (0, vitest_1.expect)(agent.inputGuardrails).toHaveLength(2); // pre_flight + input
            (0, vitest_1.expect)(agent.outputGuardrails).toHaveLength(1);
        });
        (0, vitest_1.it)('should pass through additional agent kwargs', async () => {
            const config = {
                version: 1,
                input: {
                    version: 1,
                    guardrails: [{ name: 'Keywords', config: {} }],
                },
            };
            const agentKwargs = {
                model: 'gpt-4',
                temperature: 0.7,
                max_tokens: 1000,
            };
            const agent = (await agents_1.GuardrailAgent.create(config, 'Test Agent', 'Test instructions', agentKwargs));
            (0, vitest_1.expect)(agent.model).toBe('gpt-4');
            (0, vitest_1.expect)(agent.temperature).toBe(0.7);
            (0, vitest_1.expect)(agent.max_tokens).toBe(1000);
        });
        (0, vitest_1.it)('should handle empty configuration gracefully', async () => {
            const config = { version: 1 };
            const agent = (await agents_1.GuardrailAgent.create(config, 'Test Agent', 'Test instructions'));
            (0, vitest_1.expect)(agent.name).toBe('Test Agent');
            (0, vitest_1.expect)(agent.instructions).toBe('Test instructions');
            (0, vitest_1.expect)(agent.inputGuardrails).toHaveLength(0);
            (0, vitest_1.expect)(agent.outputGuardrails).toHaveLength(0);
        });
        (0, vitest_1.it)('should accept raiseGuardrailErrors parameter', async () => {
            const config = {
                version: 1,
                input: {
                    version: 1,
                    guardrails: [{ name: 'Keywords', config: {} }],
                },
            };
            const agent = (await agents_1.GuardrailAgent.create(config, 'Test Agent', 'Test instructions', {}, true // raiseGuardrailErrors = true
            ));
            (0, vitest_1.expect)(agent.name).toBe('Test Agent');
            (0, vitest_1.expect)(agent.instructions).toBe('Test instructions');
            (0, vitest_1.expect)(agent.inputGuardrails).toHaveLength(1);
        });
        (0, vitest_1.it)('should default raiseGuardrailErrors to false', async () => {
            const config = {
                version: 1,
                input: {
                    version: 1,
                    guardrails: [{ name: 'Keywords', config: {} }],
                },
            };
            const agent = (await agents_1.GuardrailAgent.create(config, 'Test Agent', 'Test instructions'));
            (0, vitest_1.expect)(agent.name).toBe('Test Agent');
            (0, vitest_1.expect)(agent.instructions).toBe('Test instructions');
            (0, vitest_1.expect)(agent.inputGuardrails).toHaveLength(1);
        });
        (0, vitest_1.it)('should throw error when @openai/agents is not available', async () => {
            // This test would require more complex mocking setup
            // For now, we'll skip it since the error handling is tested in the actual implementation
            (0, vitest_1.expect)(true).toBe(true); // Placeholder assertion
        });
        (0, vitest_1.it)('should work without instructions parameter', async () => {
            const config = { version: 1 };
            // Should not throw TypeError about missing instructions
            const agent = (await agents_1.GuardrailAgent.create(config, 'NoInstructions'));
            (0, vitest_1.expect)(agent.name).toBe('NoInstructions');
            (0, vitest_1.expect)(agent.instructions).toBeUndefined();
        });
        (0, vitest_1.it)('should accept callable instructions', async () => {
            const config = { version: 1 };
            const dynamicInstructions = (ctx, agent) => {
                return `You are ${agent.name}`;
            };
            const agent = (await agents_1.GuardrailAgent.create(config, 'DynamicAgent', dynamicInstructions));
            (0, vitest_1.expect)(agent.name).toBe('DynamicAgent');
            (0, vitest_1.expect)(typeof agent.instructions).toBe('function');
            (0, vitest_1.expect)(agent.instructions).toBe(dynamicInstructions);
        });
        (0, vitest_1.it)('should merge user input guardrails with config guardrails', async () => {
            const config = {
                version: 1,
                input: {
                    version: 1,
                    guardrails: [{ name: 'Keywords', config: {} }],
                },
            };
            // Create a custom user guardrail
            const customGuardrail = {
                name: 'Custom Input Guard',
                execute: async () => ({ outputInfo: {}, tripwireTriggered: false }),
            };
            const agent = (await agents_1.GuardrailAgent.create(config, 'MergedAgent', 'Test instructions', {
                inputGuardrails: [customGuardrail],
            }));
            // Should have both config and user guardrails merged (config first, then user)
            (0, vitest_1.expect)(agent.inputGuardrails).toHaveLength(2);
            (0, vitest_1.expect)(agent.inputGuardrails[0].name).toContain('input:');
            (0, vitest_1.expect)(agent.inputGuardrails[1].name).toBe('Custom Input Guard');
        });
        (0, vitest_1.it)('should merge user output guardrails with config guardrails', async () => {
            const config = {
                version: 1,
                output: {
                    version: 1,
                    guardrails: [{ name: 'URL Filter', config: {} }],
                },
            };
            // Create a custom user guardrail
            const customGuardrail = {
                name: 'Custom Output Guard',
                execute: async () => ({ outputInfo: {}, tripwireTriggered: false }),
            };
            const agent = (await agents_1.GuardrailAgent.create(config, 'MergedAgent', 'Test instructions', {
                outputGuardrails: [customGuardrail],
            }));
            // Should have both config and user guardrails merged (config first, then user)
            (0, vitest_1.expect)(agent.outputGuardrails).toHaveLength(2);
            (0, vitest_1.expect)(agent.outputGuardrails[0].name).toContain('output:');
            (0, vitest_1.expect)(agent.outputGuardrails[1].name).toBe('Custom Output Guard');
        });
        (0, vitest_1.it)('should handle empty user guardrail arrays gracefully', async () => {
            const config = { version: 1 };
            const agent = (await agents_1.GuardrailAgent.create(config, 'EmptyListAgent', 'Test instructions', {
                inputGuardrails: [],
                outputGuardrails: [],
            }));
            (0, vitest_1.expect)(agent.name).toBe('EmptyListAgent');
            (0, vitest_1.expect)(agent.inputGuardrails).toHaveLength(0);
            (0, vitest_1.expect)(agent.outputGuardrails).toHaveLength(0);
        });
    });
    (0, vitest_1.describe)('guardrail function creation', () => {
        (0, vitest_1.it)('should create guardrail functions that return correct structure', async () => {
            const config = {
                version: 1,
                input: {
                    version: 1,
                    guardrails: [{ name: 'Keywords', config: {} }],
                },
            };
            const agent = (await agents_1.GuardrailAgent.create(config, 'Test Agent', 'Test instructions'));
            (0, vitest_1.expect)(agent.inputGuardrails).toHaveLength(1);
            // Test the guardrail function
            const guardrailFunction = agent.inputGuardrails[0];
            const result = await guardrailFunction.execute('test input');
            (0, vitest_1.expect)(result).toHaveProperty('outputInfo');
            (0, vitest_1.expect)(result).toHaveProperty('tripwireTriggered');
            (0, vitest_1.expect)(typeof result.tripwireTriggered).toBe('boolean');
        });
        (0, vitest_1.it)('passes the latest user message text to guardrails for conversation inputs', async () => {
            process.env.OPENAI_API_KEY = 'test';
            const config = {
                version: 1,
                input: {
                    version: 1,
                    guardrails: [{ name: 'Moderation', config: {} }],
                },
            };
            const { instantiateGuardrails } = await Promise.resolve().then(() => __importStar(require('../../runtime')));
            const runSpy = vitest_1.vi.fn().mockResolvedValue({
                tripwireTriggered: false,
                info: { guardrail_name: 'Moderation' },
            });
            vitest_1.vi.mocked(instantiateGuardrails).mockImplementationOnce(() => Promise.resolve([
                {
                    definition: {
                        name: 'Moderation',
                        description: 'Moderation guardrail',
                        mediaType: 'text/plain',
                        configSchema: zod_1.z.object({}),
                        checkFn: vitest_1.vi.fn(),
                        metadata: { usesConversationHistory: true }, // Mark as conversation-aware to trigger context creation
                        ctxRequirements: zod_1.z.object({}),
                        schema: () => ({}),
                        instantiate: vitest_1.vi.fn(),
                    },
                    config: {},
                    run: runSpy,
                },
            ]));
            const agent = (await agents_1.GuardrailAgent.create(config, 'Conversation Agent', 'Handle multi-turn conversations'));
            const guardrail = agent.inputGuardrails[0];
            const conversation = [
                { role: 'system', content: 'You are helpful.' },
                { role: 'user', content: [{ type: 'input_text', text: 'First question?' }] },
                { role: 'assistant', content: [{ type: 'output_text', text: 'An answer.' }] },
                {
                    role: 'user',
                    content: [
                        { type: 'input_text', text: 'Latest user message' },
                        { type: 'input_text', text: 'with additional context.' },
                    ],
                },
            ];
            const result = await guardrail.execute({ input: conversation, context: {} });
            (0, vitest_1.expect)(runSpy).toHaveBeenCalledTimes(1);
            const [ctxArgRaw, dataArg] = runSpy.mock.calls[0];
            const ctxArg = ctxArgRaw;
            (0, vitest_1.expect)(dataArg).toBe('Latest user message with additional context.');
            (0, vitest_1.expect)(typeof ctxArg.getConversationHistory).toBe('function');
            const history = ctxArg.getConversationHistory?.();
            (0, vitest_1.expect)(Array.isArray(history)).toBe(true);
            (0, vitest_1.expect)(history && history[history.length - 1]?.content).toBe('Latest user message with additional context.');
            (0, vitest_1.expect)(result.tripwireTriggered).toBe(false);
            (0, vitest_1.expect)(result.outputInfo.input).toBe('Latest user message with additional context.');
        });
        (0, vitest_1.it)('should handle guardrail execution errors based on raiseGuardrailErrors setting', async () => {
            process.env.OPENAI_API_KEY = 'test';
            const config = {
                version: 1,
                input: {
                    version: 1,
                    guardrails: [{ name: 'Keywords', config: {} }],
                },
            };
            // Mock a guardrail that throws an error
            const { instantiateGuardrails } = await Promise.resolve().then(() => __importStar(require('../../runtime')));
            vitest_1.vi.mocked(instantiateGuardrails).mockImplementationOnce(() => Promise.resolve([
                {
                    definition: {
                        name: 'Keywords',
                        description: 'Test guardrail',
                        mediaType: 'text/plain',
                        configSchema: zod_1.z.object({}),
                        checkFn: vitest_1.vi.fn(),
                        metadata: {},
                        ctxRequirements: zod_1.z.object({}),
                        schema: () => ({}),
                        instantiate: vitest_1.vi.fn(),
                    },
                    config: {},
                    run: vitest_1.vi.fn().mockRejectedValue(new Error('Guardrail execution failed')),
                },
            ]));
            // Test with raiseGuardrailErrors = false (default behavior)
            const agentDefault = (await agents_1.GuardrailAgent.create(config, 'Test Agent', 'Test instructions', {}, false));
            const guardrailFunctionDefault = agentDefault.inputGuardrails[0];
            const resultDefault = await guardrailFunctionDefault.execute('test');
            // When raiseGuardrailErrors=false, execution errors should NOT trigger tripwires
            // This allows execution to continue in fail-safe mode
            (0, vitest_1.expect)(resultDefault.tripwireTriggered).toBe(false);
            (0, vitest_1.expect)(resultDefault.outputInfo).toBeDefined();
            (0, vitest_1.expect)(resultDefault.outputInfo.error).toBe('Guardrail execution failed');
            // Reset the mock for the second test
            vitest_1.vi.mocked(instantiateGuardrails).mockImplementationOnce(() => Promise.resolve([
                {
                    definition: {
                        name: 'Keywords',
                        description: 'Test guardrail',
                        mediaType: 'text/plain',
                        configSchema: zod_1.z.object({}),
                        checkFn: vitest_1.vi.fn(),
                        metadata: {},
                        ctxRequirements: zod_1.z.object({}),
                        schema: () => ({}),
                        instantiate: vitest_1.vi.fn(),
                    },
                    config: {},
                    run: vitest_1.vi.fn().mockRejectedValue(new Error('Guardrail execution failed')),
                },
            ]));
            // Test with raiseGuardrailErrors = true (fail-secure mode)
            const agentStrict = (await agents_1.GuardrailAgent.create(config, 'Test Agent', 'Test instructions', {}, true));
            const guardrailFunctionStrict = agentStrict.inputGuardrails[0];
            // When raiseGuardrailErrors=true, execution errors should be thrown
            await (0, vitest_1.expect)(guardrailFunctionStrict.execute('test')).rejects.toThrow('Guardrail execution failed');
        });
    });
});
//# sourceMappingURL=agents.test.js.map