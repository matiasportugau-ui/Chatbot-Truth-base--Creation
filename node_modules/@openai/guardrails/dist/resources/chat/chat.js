"use strict";
/**
 * Chat completions with guardrails.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChatCompletions = exports.Chat = void 0;
const safety_identifier_1 = require("../../utils/safety-identifier");
// Note: We need to filter out non-text content since guardrails only work with text
// The existing extractLatestUserTextMessage method expects TextOnlyMessageArray
/**
 * Chat completions with guardrails.
 */
class Chat {
    constructor(client) {
        this.client = client;
    }
    get completions() {
        return new ChatCompletions(this.client);
    }
}
exports.Chat = Chat;
/**
 * Chat completions interface with guardrails.
 */
class ChatCompletions {
    constructor(client) {
        this.client = client;
    }
    async create(params) {
        const { messages, model, stream = false, suppressTripwire = false, ...kwargs } = params;
        // Extract latest user message text for guardrails (guardrails only work with text content)
        const [latestMessage] = this.client.extractLatestUserTextMessage(messages);
        const normalizedConversation = this.client.normalizeConversationHistory(messages);
        // Preflight first
        const preflightResults = await this.client.runStageGuardrails('pre_flight', latestMessage, normalizedConversation, suppressTripwire, this.client.raiseGuardrailErrors);
        // Apply pre-flight modifications (PII masking, etc.)
        const modifiedMessages = this.client.applyPreflightModifications(messages, preflightResults);
        // Run input guardrails and LLM call concurrently
        // Access protected _resourceClient - necessary for external resource classes
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const resourceClient = this.client._resourceClient;
        // Build API call parameters
        const apiParams = {
            messages: modifiedMessages,
            model,
            stream,
            ...kwargs,
        };
        // Only include safety_identifier for official OpenAI API (not Azure or local providers)
        if ((0, safety_identifier_1.supportsSafetyIdentifier)(resourceClient)) {
            // @ts-ignore - safety_identifier is not defined in OpenAI types yet
            apiParams.safety_identifier = safety_identifier_1.SAFETY_IDENTIFIER;
        }
        const [inputResults, llmResponse] = await Promise.all([
            this.client.runStageGuardrails('input', latestMessage, normalizedConversation, suppressTripwire, this.client.raiseGuardrailErrors),
            resourceClient.chat.completions.create(apiParams),
        ]);
        // Handle streaming vs non-streaming
        if (stream) {
            const { StreamingMixin } = require('../../streaming');
            return StreamingMixin.streamWithGuardrailsSync(this.client, llmResponse, preflightResults, inputResults, normalizedConversation, suppressTripwire);
        }
        else {
            // Access protected handleLlmResponse - necessary for external resource classes
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            return this.client.handleLlmResponse(llmResponse, preflightResults, inputResults, normalizedConversation, suppressTripwire);
        }
    }
}
exports.ChatCompletions = ChatCompletions;
//# sourceMappingURL=chat.js.map