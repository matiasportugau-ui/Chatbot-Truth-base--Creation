"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Responses = void 0;
const conversation_1 = require("../../utils/conversation");
const safety_identifier_1 = require("../../utils/safety-identifier");
/**
 * Responses API with guardrails.
 */
class Responses {
    constructor(client) {
        this.client = client;
    }
    async create(params) {
        const { input, model, stream = false, tools, suppressTripwire = false, ...kwargs } = params;
        const extraOptions = kwargs;
        const previousResponseIdValue = extraOptions['previous_response_id'] ?? extraOptions['previousResponseId'];
        const previousResponseId = typeof previousResponseIdValue === 'string' ? previousResponseIdValue : undefined;
        const priorHistory = await this.client.loadConversationHistoryFromPreviousResponse(previousResponseId);
        const currentTurn = this.client.normalizeConversationHistory(input);
        const normalizedConversation = priorHistory.length > 0 ? (0, conversation_1.mergeConversationWithItems)(priorHistory, currentTurn) : currentTurn;
        // Determine latest user message text when a list of messages is provided
        let latestMessage;
        if (Array.isArray(input)) {
            [latestMessage] = this.client.extractLatestUserTextMessage(input);
        }
        else {
            latestMessage = input;
        }
        // Preflight first (run checks on the latest user message text, with full conversation)
        const preflightResults = await this.client.runStageGuardrails('pre_flight', latestMessage, normalizedConversation, suppressTripwire, this.client.raiseGuardrailErrors);
        // Apply pre-flight modifications (PII masking, etc.)
        const modifiedInput = this.client.applyPreflightModifications(input, preflightResults);
        // Input guardrails and LLM call concurrently
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const resourceClient = this.client._resourceClient;
        // Build API call parameters
        const apiParams = {
            input: modifiedInput,
            model,
            stream,
            tools,
            ...kwargs,
        };
        // Only include safety_identifier for official OpenAI API (not Azure or local providers)
        if ((0, safety_identifier_1.supportsSafetyIdentifier)(resourceClient)) {
            // @ts-ignore - safety_identifier is not defined in OpenAI types yet
            apiParams.safety_identifier = safety_identifier_1.SAFETY_IDENTIFIER;
        }
        const [inputResults, llmResponse] = await Promise.all([
            this.client.runStageGuardrails('input', latestMessage, normalizedConversation, suppressTripwire, this.client.raiseGuardrailErrors),
            resourceClient.responses.create(apiParams),
        ]);
        // Handle streaming vs non-streaming
        if (stream) {
            const { StreamingMixin } = require('../../streaming');
            return StreamingMixin.streamWithGuardrailsSync(this.client, llmResponse, preflightResults, inputResults, normalizedConversation, suppressTripwire);
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            return this.client.handleLlmResponse(llmResponse, preflightResults, inputResults, normalizedConversation, suppressTripwire);
        }
    }
}
exports.Responses = Responses;
//# sourceMappingURL=responses.js.map