"use strict";
/**
 * Runtime execution helpers for guardrails.
 *
 * This module provides the bridge between configuration and runtime execution for
 * guardrail validation.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfiguredGuardrail = void 0;
exports.checkPlainText = checkPlainText;
exports.runGuardrails = runGuardrails;
exports.instantiateGuardrails = instantiateGuardrails;
exports.loadConfigBundle = loadConfigBundle;
exports.loadConfigBundleFromFile = loadConfigBundleFromFile;
exports.loadPipelineBundles = loadPipelineBundles;
const registry_1 = require("./registry");
/**
 * A configured, executable guardrail.
 *
 * This class binds a `GuardrailSpec` definition to a validated configuration
 * object. The resulting instance is used to run guardrail logic in production
 * pipelines. It supports both sync and async check functions.
 */
class ConfiguredGuardrail {
    constructor(definition, config) {
        this.definition = definition;
        this.config = config;
    }
    /**
     * Ensure a guardrail function is executed asynchronously.
     *
     * If the function is sync, runs it in a Promise.resolve for compatibility with async flows.
     * If already async, simply awaits it. Used internally to normalize execution style.
     *
     * @param fn Guardrail check function (sync or async).
     * @param args Arguments for the check function.
     * @returns Promise resolving to the result of the check function.
     */
    async ensureAsync(fn, ...args) {
        const result = fn(...args);
        if (result instanceof Promise) {
            return await result;
        }
        return result;
    }
    /**
     * Run the guardrail's check function with the provided context and data.
     *
     * Main entry point for executing guardrails. Supports both sync and async
     * functions, ensuring results are always awaited.
     *
     * @param ctx Runtime context for the guardrail.
     * @param data Input value to be checked.
     * @returns Promise resolving to the outcome of the guardrail logic.
     */
    async run(ctx, data) {
        return await this.ensureAsync(this.definition.checkFn, ctx, data, this.config);
    }
}
exports.ConfiguredGuardrail = ConfiguredGuardrail;
/**
 * Run a single guardrail bundle on plain text input.
 *
 * This is a high-level convenience function that loads a bundle configuration
 * and runs all guardrails in parallel, throwing an exception if any tripwire
 * is triggered.
 *
 * @param text Input text to validate.
 * @param bundle Guardrail bundle configuration.
 * @param context Optional context object for the guardrails.
 * @throws {Error} If any guardrail tripwire is triggered.
 */
async function checkPlainText(text, bundle, context) {
    const results = await runGuardrails(text, bundle, context);
    // Check if any tripwires were triggered
    const triggeredResults = results.filter((r) => r.tripwireTriggered);
    if (triggeredResults.length > 0) {
        const error = new Error(`Content validation failed: ${triggeredResults.length} security violation(s) detected`);
        Object.defineProperty(error, 'guardrailResults', {
            value: triggeredResults,
            writable: false,
            enumerable: true,
        });
        throw error;
    }
}
/**
 * Run multiple guardrails in parallel and return all results.
 *
 * This function orchestrates the execution of multiple guardrails,
 * running them concurrently for better performance.
 *
 * @param data Input data to validate.
 * @param bundle Guardrail bundle configuration.
 * @param context Optional context object for the guardrails.
 * @param raiseGuardrailErrors If true, raise exceptions when guardrails fail to execute.
 * @returns Array of guardrail results.
 */
async function runGuardrails(data, bundle, context, raiseGuardrailErrors = false) {
    const guardrails = await instantiateGuardrails(bundle);
    // Run all guardrails in parallel
    const promises = guardrails.map(async (guardrail) => {
        try {
            return await guardrail.run(context || {}, data);
        }
        catch (error) {
            return {
                tripwireTriggered: false, // Don't trigger tripwire on execution errors
                executionFailed: true,
                originalException: error instanceof Error ? error : new Error(String(error)),
                info: {
                    error: error instanceof Error ? error.message : String(error),
                    guardrailName: guardrail.definition.metadata?.name || 'Unknown',
                },
            };
        }
    });
    const results = (await Promise.all(promises));
    // Check for guardrail execution failures and re-raise if configured
    if (raiseGuardrailErrors) {
        const executionFailures = results.filter((r) => r.executionFailed);
        if (executionFailures.length > 0) {
            // Re-raise the first execution failure
            console.debug('Re-raising guardrail execution error due to raiseGuardrailErrors=true');
            throw executionFailures[0].originalException;
        }
    }
    return results;
}
/**
 * Instantiate guardrails from a bundle configuration.
 *
 * Creates configured guardrail instances from a bundle specification,
 * validating configurations against their schemas.
 *
 * @param bundle Guardrail bundle configuration.
 * @returns Array of configured guardrail instances.
 */
async function instantiateGuardrails(bundle) {
    const guardrails = [];
    for (const guardrailConfig of bundle.guardrails) {
        const spec = registry_1.defaultSpecRegistry.get(guardrailConfig.name);
        if (!spec) {
            throw new Error(`Guardrail '${guardrailConfig.name}' not found in registry`);
        }
        try {
            // Validate configuration against schema if available
            let validatedConfig = guardrailConfig.config;
            if (spec.configSchema) {
                validatedConfig = spec.configSchema.parse(guardrailConfig.config);
            }
            const guardrail = spec.instantiate(validatedConfig);
            guardrails.push(guardrail);
        }
        catch (error) {
            throw new Error(`Failed to instantiate guardrail '${guardrailConfig.name}': ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    return guardrails;
}
/**
 * Load a guardrail bundle configuration from a JSON string.
 *
 * @param jsonString JSON string containing bundle configuration.
 * @returns Parsed guardrail bundle.
 */
function loadConfigBundle(jsonString) {
    try {
        const parsed = JSON.parse(jsonString);
        // Handle nested structure (input.guardrails) or direct structure (guardrails)
        let guardrailsArray;
        if (parsed.guardrails && Array.isArray(parsed.guardrails)) {
            // Direct structure
            guardrailsArray = parsed.guardrails;
        }
        else if (parsed.input && parsed.input.guardrails && Array.isArray(parsed.input.guardrails)) {
            // Nested structure
            guardrailsArray = parsed.input.guardrails;
        }
        else {
            throw new Error('Invalid bundle format: missing or invalid guardrails array (expected either "guardrails" or "input.guardrails")');
        }
        // Validate each guardrail config
        for (const guardrail of guardrailsArray) {
            const guardrailObj = guardrail;
            if (!guardrailObj.name || typeof guardrailObj.name !== 'string') {
                throw new Error('Invalid guardrail config: missing or invalid name');
            }
            if (!guardrailObj.config || typeof guardrailObj.config !== 'object') {
                throw new Error('Invalid guardrail config: missing or invalid config object');
            }
        }
        // Return in the expected format
        return {
            version: parsed.version,
            stageName: parsed.stageName,
            guardrails: guardrailsArray,
        };
    }
    catch (error) {
        if (error instanceof SyntaxError) {
            throw new Error(`Invalid JSON: ${error.message}`);
        }
        throw error;
    }
}
/**
 * Load a guardrail bundle configuration from a file.
 *
 * Note: This function requires Node.js fs module and will only work in Node.js environments.
 *
 * @param filePath Path to the JSON configuration file.
 * @returns Parsed guardrail bundle.
 */
async function loadConfigBundleFromFile(filePath) {
    // Dynamic import to avoid bundling issues
    const fs = await Promise.resolve().then(() => __importStar(require('fs/promises')));
    const content = await fs.readFile(filePath, 'utf-8');
    return loadConfigBundle(content);
}
/**
 * Load pipeline configuration from string or object.
 *
 * @param config Pipeline configuration as string or object
 * @returns Parsed pipeline configuration
 */
async function loadPipelineBundles(config) {
    if (typeof config === 'string') {
        // Check if it's a file path (contains .json extension or path separators)
        if (config.includes('.json') || config.includes('/') || config.includes('\\')) {
            // Dynamic import to avoid bundling issues
            const fs = await Promise.resolve().then(() => __importStar(require('fs/promises')));
            const content = await fs.readFile(config, 'utf-8');
            return JSON.parse(content);
        }
        else {
            // It's a JSON string
            return JSON.parse(config);
        }
    }
    return config;
}
//# sourceMappingURL=runtime.js.map