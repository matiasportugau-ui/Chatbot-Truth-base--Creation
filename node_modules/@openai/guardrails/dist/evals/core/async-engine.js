"use strict";
/**
 * Async run engine for guardrail evaluation.
 *
 * This module provides an asynchronous engine for running guardrail checks on evaluation samples.
 * It supports batch processing, error handling, and progress reporting for large-scale evaluation workflows.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AsyncRunEngine = void 0;
const conversation_1 = require("../../utils/conversation");
/**
 * Extract plain text from message content, handling multi-part structures.
 *
 * OpenAI ChatAPI supports content as either:
 * - String: "hello world"
 * - List of parts: [{"type": "text", "text": "hello"}, {"type": "image_url", ...}]
 *
 * @param content - Message content (string, list of parts, or other)
 * @returns Extracted text as a plain string
 */
function extractTextFromContent(content) {
    // Content is already a string
    if (typeof content === 'string') {
        return content;
    }
    // Content is a list of parts (multi-modal message)
    if (Array.isArray(content)) {
        if (content.length === 0) {
            return '';
        }
        const textParts = [];
        for (const part of content) {
            if (part && typeof part === 'object') {
                // Extract text from various field names
                let text = null;
                const partObj = part;
                for (const field of ['text', 'input_text', 'output_text']) {
                    if (field in partObj) {
                        text = partObj[field];
                        break;
                    }
                }
                if (text !== null && typeof text === 'string') {
                    textParts.push(text);
                }
            }
        }
        return textParts.join(' ');
    }
    // Fallback: stringify other types
    return content !== null && content !== undefined ? String(content) : '';
}
/**
 * Runs guardrail evaluations asynchronously.
 */
class AsyncRunEngine {
    constructor(guardrails, multiTurn = false) {
        this.guardrailNames = guardrails.map((g) => g.definition.name);
        this.guardrails = guardrails;
        this.multiTurn = multiTurn;
    }
    /**
     * Run evaluations on samples in batches.
     *
     * @param context - Evaluation context
     * @param samples - List of samples to evaluate
     * @param batchSize - Number of samples to process in parallel
     * @param desc - Description for the progress reporting
     * @returns List of evaluation results
     *
     * @throws {Error} If batchSize is less than 1
     */
    async run(context, samples, batchSize, desc = 'Evaluating samples') {
        if (batchSize < 1) {
            throw new Error('batchSize must be at least 1');
        }
        const results = [];
        const totalSamples = samples.length;
        console.log(`${desc}: ${totalSamples} samples, batch size: ${batchSize}`);
        for (let i = 0; i < samples.length; i += batchSize) {
            const batch = samples.slice(i, i + batchSize);
            const batchResults = await Promise.all(batch.map((sample) => this.evaluateSample(context, sample)));
            results.push(...batchResults);
            console.log(`Processed ${results.length}/${totalSamples} samples`);
        }
        return results;
    }
    /**
     * Evaluate a single sample against all guardrails.
     *
     * @param context - Evaluation context
     * @param sample - Sample to evaluate
     * @returns Evaluation result for the sample
     */
    async evaluateSample(context, sample) {
        const triggered = {};
        const details = {};
        for (const name of this.guardrailNames) {
            triggered[name] = false;
        }
        try {
            for (let i = 0; i < this.guardrails.length; i += 1) {
                const guardrail = this.guardrails[i];
                const name = this.guardrailNames[i] || guardrail.definition.name || 'unknown';
                try {
                    const result = await this.runGuardrailWithIncrementalSupport(context, guardrail, sample.data);
                    triggered[name] = result.tripwireTriggered;
                    if (result.info) {
                        details[name] = result.info;
                    }
                }
                catch (guardrailError) {
                    console.error(`Error running guardrail ${name} on sample ${sample.id}:`, guardrailError);
                    triggered[name] = false;
                    details[name] = {
                        input_text: sample.data,
                        error: guardrailError instanceof Error ? guardrailError.message : String(guardrailError),
                    };
                }
            }
        }
        catch (error) {
            console.error(`Error evaluating sample ${sample.id}:`, error);
            return {
                id: sample.id,
                expectedTriggers: sample.expectedTriggers,
                triggered,
                details: {
                    ...details,
                    error: error instanceof Error ? error.message : String(error),
                },
            };
        }
        return {
            id: sample.id,
            expectedTriggers: sample.expectedTriggers,
            triggered,
            details,
        };
    }
    async runGuardrailWithIncrementalSupport(context, guardrail, sampleData) {
        const usesConversationHistory = this.guardrailUsesConversationHistory(guardrail);
        // Run incrementally if the guardrail uses conversation history and multi-turn is enabled
        const shouldRunIncremental = usesConversationHistory && this.multiTurn;
        if (shouldRunIncremental) {
            return await this.runIncrementalConversationGuardrail(context, guardrail, sampleData);
        }
        if (usesConversationHistory) {
            return await this.runConversationGuardrailSinglePass(context, guardrail, sampleData);
        }
        const userPayload = this.extractLatestUserPayload(sampleData);
        return await guardrail.run(context, userPayload);
    }
    extractLatestUserPayload(sampleData) {
        const conversation = (0, conversation_1.normalizeConversation)((0, conversation_1.parseConversationInput)(sampleData));
        if (conversation.length === 0) {
            return sampleData;
        }
        // Extract from the latest user message only (not tool/function messages without roles)
        for (let idx = conversation.length - 1; idx >= 0; idx -= 1) {
            const entry = conversation[idx];
            if (entry.role === 'user') {
                const extracted = this.extractLatestInput(entry, sampleData);
                if (extracted.trim().length > 0) {
                    return extracted;
                }
            }
        }
        // Fallback: if no user message found, return full sample data
        return sampleData;
    }
    guardrailUsesConversationHistory(guardrail) {
        return Boolean(guardrail.definition.metadata?.usesConversationHistory);
    }
    async runConversationGuardrailSinglePass(context, guardrail, sampleData) {
        const conversation = (0, conversation_1.normalizeConversation)((0, conversation_1.parseConversationInput)(sampleData));
        const guardrailContext = this.createConversationContext(context, conversation);
        return await guardrail.run(guardrailContext, sampleData);
    }
    async runIncrementalConversationGuardrail(context, guardrail, sampleData) {
        const conversation = (0, conversation_1.normalizeConversation)((0, conversation_1.parseConversationInput)(sampleData));
        if (conversation.length === 0) {
            const guardrailContext = this.createConversationContext(context, []);
            return await guardrail.run(guardrailContext, sampleData);
        }
        let finalResult = null;
        for (let turnIndex = 0; turnIndex < conversation.length; turnIndex += 1) {
            const historySlice = conversation.slice(0, turnIndex + 1);
            const guardrailContext = this.createConversationContext(context, historySlice);
            const latestMessage = historySlice[historySlice.length - 1];
            // Extract the latest input from the current message
            const serializedHistory = safeStringify(historySlice, sampleData);
            const payload = this.extractLatestInput(latestMessage, serializedHistory);
            const result = await guardrail.run(guardrailContext, payload);
            finalResult = result;
            this.annotateIncrementalResult(result, turnIndex, latestMessage);
            if (result.tripwireTriggered) {
                break;
            }
        }
        if (!finalResult) {
            return {
                tripwireTriggered: false,
                info: {
                    guardrail_name: guardrail.definition.name,
                    observation: 'No conversation turns evaluated',
                    flagged: false,
                    confidence: 0.0,
                    input_text: sampleData,
                },
            };
        }
        return finalResult;
    }
    extractLatestInput(message, fallback) {
        if (!message) {
            return fallback;
        }
        // Handle multi-part content structures (e.g., ChatAPI content parts)
        const content = extractTextFromContent(message.content);
        if (content && content.trim().length > 0) {
            return content.trim();
        }
        const args = typeof message.arguments === 'string' ? message.arguments : null;
        if (args && args.trim().length > 0) {
            return args.trim();
        }
        const output = typeof message.output === 'string' ? message.output : null;
        if (output && output.trim().length > 0) {
            return output.trim();
        }
        return fallback;
    }
    annotateIncrementalResult(result, turnIndex, message) {
        if (!result.info) {
            result.info = {};
        }
        result.info.turn_index = turnIndex;
        if (message && typeof message === 'object') {
            if (message.role && result.info.trigger_role === undefined) {
                result.info.trigger_role = message.role;
            }
            if (result.info.trigger_message === undefined) {
                result.info.trigger_message = message;
            }
        }
    }
    createConversationContext(context, conversationHistory) {
        // Expose conversation_history as both a property and a method for compatibility
        return {
            guardrailLlm: context.guardrailLlm,
            conversationHistory,
            getConversationHistory: () => conversationHistory,
        };
    }
}
exports.AsyncRunEngine = AsyncRunEngine;
function safeStringify(value, fallback) {
    try {
        return JSON.stringify(value, null, 2);
    }
    catch {
        return fallback;
    }
}
//# sourceMappingURL=async-engine.js.map