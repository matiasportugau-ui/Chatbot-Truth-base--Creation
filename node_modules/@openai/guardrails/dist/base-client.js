"use strict";
/**
 * Base client functionality for guardrails integration.
 *
 * This module contains the shared base class and data structures used by both
 * async and sync guardrails clients.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.GuardrailsBaseClient = exports.GuardrailResultsImpl = void 0;
const content_1 = require("./utils/content");
const runtime_1 = require("./runtime");
const conversation_1 = require("./utils/conversation");
const ZERO_WIDTH_CHARACTERS = /(?:\u200B|\u200C|\u200D|\u2060|\uFEFF)/g;
function toRecord(value) {
    if (typeof value === 'object' && value !== null) {
        return value;
    }
    return null;
}
function getRecord(record, key) {
    if (!record) {
        return null;
    }
    return toRecord(record[key]);
}
function getFunction(record, key) {
    if (!record) {
        return null;
    }
    const candidate = record[key];
    return typeof candidate === 'function' ? candidate : null;
}
function isAsyncIterable(value) {
    if (typeof value !== 'object' || value === null) {
        return false;
    }
    const iterator = value[Symbol.asyncIterator];
    return typeof iterator === 'function';
}
/**
 * Extension of GuardrailResults with convenience methods.
 */
class GuardrailResultsImpl {
    constructor(preflight, input, output) {
        this.preflight = preflight;
        this.input = input;
        this.output = output;
    }
    get allResults() {
        return [...this.preflight, ...this.input, ...this.output];
    }
    get tripwiresTriggered() {
        return this.allResults.some((r) => r.tripwireTriggered);
    }
    get triggeredResults() {
        return this.allResults.filter((r) => r.tripwireTriggered);
    }
}
exports.GuardrailResultsImpl = GuardrailResultsImpl;
/**
 * Base class with shared functionality for guardrails clients.
 */
class GuardrailsBaseClient {
    constructor() {
        this.raiseGuardrailErrors = false;
    }
    /**
     * Extract the latest user text message from a conversation for text guardrails.
     *
     * This method specifically extracts text content from messages. For other content types,
     * create parallel methods like extractLatestUserImage() or extractLatestUserVideo().
     */
    extractLatestUserTextMessage(messages) {
        const textOnlyMessages = content_1.ContentUtils.filterToTextOnly(messages);
        for (let i = textOnlyMessages.length - 1; i >= 0; i -= 1) {
            const message = textOnlyMessages[i];
            if (message.role === 'user') {
                const text = content_1.ContentUtils.extractTextFromMessage(message);
                if (text) {
                    return [text, i];
                }
            }
        }
        return ['', -1];
    }
    createGuardrailsResponse(llmResponse, preflightResults, inputResults, outputResults) {
        const guardrailResults = new GuardrailResultsImpl(preflightResults, inputResults, outputResults);
        return {
            ...llmResponse,
            guardrail_results: guardrailResults,
        };
    }
    async setupGuardrails(config, context) {
        this.pipeline = await this.loadPipelineBundles(config);
        this.guardrails = await this.instantiateAllGuardrails();
        this.context = context || this.createDefaultContext();
        this.validateContext(this.context);
    }
    applyPreflightModifications(data, preflightResults) {
        if (preflightResults.length === 0) {
            return data;
        }
        const piiMappings = {};
        let maskedTextOverride;
        for (const result of preflightResults) {
            if (result.info && 'detected_entities' in result.info) {
                const detected = result.info.detected_entities;
                for (const [entityType, entities] of Object.entries(detected)) {
                    for (const entity of entities) {
                        piiMappings[entity] = `<${entityType}>`;
                    }
                }
                if (typeof result.info.checked_text === 'string' && !maskedTextOverride) {
                    maskedTextOverride = result.info.checked_text;
                }
            }
        }
        if (!maskedTextOverride && Object.keys(piiMappings).length === 0) {
            return data;
        }
        const normalizeForMasking = (text) => text.normalize('NFKC').replace(ZERO_WIDTH_CHARACTERS, '');
        const originalStringData = typeof data === 'string' ? data : undefined;
        const maskText = (text) => {
            if (typeof text !== 'string') {
                return text;
            }
            const hasMappings = Object.keys(piiMappings).length > 0;
            const normalizedOriginal = normalizeForMasking(text);
            let maskedText = normalizedOriginal;
            const sortedPii = Object.entries(piiMappings).sort((a, b) => b[0].length - a[0].length);
            if (hasMappings) {
                for (const [originalPii, maskedToken] of sortedPii) {
                    const normalizedKey = normalizeForMasking(originalPii);
                    if (normalizedKey && maskedText.includes(normalizedKey)) {
                        maskedText = maskedText.split(normalizedKey).join(maskedToken);
                    }
                }
            }
            const replacementsApplied = hasMappings && maskedText !== normalizedOriginal;
            if (replacementsApplied) {
                return maskedText;
            }
            if (maskedTextOverride && originalStringData !== undefined && text === originalStringData) {
                return maskedTextOverride;
            }
            return text;
        };
        if (typeof data === 'string') {
            return maskText(data);
        }
        const [, latestUserIdx] = this.extractLatestUserTextMessage(data);
        if (latestUserIdx === -1) {
            return data;
        }
        const modifiedMessages = [...data];
        const currentContent = data[latestUserIdx].content;
        let modifiedContent;
        if (typeof currentContent === 'string') {
            modifiedContent = maskText(currentContent);
        }
        else if (Array.isArray(currentContent)) {
            modifiedContent = currentContent.map((part) => {
                if (content_1.ContentUtils.isText(part)) {
                    const textPart = part;
                    return { ...textPart, text: maskText(textPart.text) };
                }
                return part;
            });
        }
        else {
            return data;
        }
        if (modifiedContent !== currentContent) {
            modifiedMessages[latestUserIdx] = {
                ...modifiedMessages[latestUserIdx],
                content: modifiedContent,
            };
        }
        return modifiedMessages;
    }
    async instantiateAllGuardrails() {
        const guardrails = {
            pre_flight: [],
            input: [],
            output: [],
        };
        for (const stageName of ['pre_flight', 'input', 'output']) {
            const stage = this.pipeline[stageName];
            guardrails[stageName] = stage ? await (0, runtime_1.instantiateGuardrails)(stage) : [];
        }
        return guardrails;
    }
    validateContext(context) {
        if (!context.guardrailLlm) {
            throw new Error('Context must have a guardrailLlm property');
        }
    }
    extractResponseText(response) {
        if ('output' in response) {
            return response.output_text || '';
        }
        if ('choices' in response && response.choices) {
            const choice0 = response.choices[0];
            if ('message' in choice0 && choice0.message) {
                return choice0.message.content || '';
            }
            if ('text' in choice0 && choice0.text) {
                return choice0.text;
            }
            if ('delta' in choice0 && choice0.delta) {
                return choice0.delta.content || '';
            }
        }
        return '';
    }
    async loadPipelineBundles(config) {
        const { loadPipelineBundles } = await Promise.resolve().then(() => __importStar(require('./runtime.js')));
        return loadPipelineBundles(config);
    }
    async initializeClient(config, openaiArgs, clientClass) {
        this._resourceClient = new clientClass(openaiArgs);
        await this.setupGuardrails(config);
        this.overrideResources();
    }
    shouldRunGuardrail(guardrail, detectedContentType) {
        return guardrail.definition.mediaType === detectedContentType;
    }
    async runStageGuardrails(stageName, text, conversationHistory, suppressTripwire = false, raiseGuardrailErrors = false) {
        if (!this.guardrails?.[stageName] || this.guardrails[stageName].length === 0) {
            return [];
        }
        try {
            const detectedContentType = 'text/plain';
            const compatibleGuardrails = this.guardrails[stageName].filter((guardrail) => this.shouldRunGuardrail(guardrail, detectedContentType));
            const skippedGuardrails = this.guardrails[stageName].filter((guardrail) => !this.shouldRunGuardrail(guardrail, detectedContentType));
            if (skippedGuardrails.length > 0) {
                console.warn(`⚠️  Guardrails Warning: ${skippedGuardrails.length} guardrails skipped due to content type mismatch ` +
                    `(detected: ${detectedContentType}). Skipped: ${skippedGuardrails
                        .map((g) => g.definition.name)
                        .join(', ')}`);
            }
            if (compatibleGuardrails.length === 0) {
                console.warn(`No guardrails compatible with content type '${detectedContentType}' for stage '${stageName}'`);
                return [];
            }
            const needsConversationHistory = compatibleGuardrails.some((guardrail) => guardrail.definition.metadata?.usesConversationHistory);
            let ctx = this.context;
            let normalizedHistory = [];
            if (needsConversationHistory && conversationHistory !== undefined) {
                normalizedHistory = this.normalizeConversationHistory(conversationHistory);
                if (normalizedHistory.length > 0) {
                    ctx = this.createContextWithConversation(normalizedHistory);
                }
            }
            const results = [];
            const guardrailPromises = compatibleGuardrails.map(async (guardrail) => {
                try {
                    const result = await guardrail.run(ctx, text);
                    result.info = {
                        ...result.info,
                        stage_name: stageName,
                        guardrail_name: guardrail.definition.name,
                        media_type: guardrail.definition.mediaType,
                        detected_content_type: detectedContentType,
                    };
                    return result;
                }
                catch (error) {
                    console.error(`Error running guardrail ${guardrail.definition.name}:`, error);
                    return {
                        tripwireTriggered: false,
                        executionFailed: true,
                        originalException: error instanceof Error ? error : new Error(String(error)),
                        info: {
                            stage_name: stageName,
                            guardrail_name: guardrail.definition.name,
                            media_type: guardrail.definition.mediaType,
                            detected_content_type: detectedContentType,
                            error: error instanceof Error ? error.message : String(error),
                        },
                    };
                }
            });
            const settledResults = await Promise.allSettled(guardrailPromises);
            for (const settledResult of settledResults) {
                if (settledResult.status === 'fulfilled') {
                    results.push(settledResult.value);
                }
            }
            if (raiseGuardrailErrors) {
                const executionFailures = results.filter((r) => r.executionFailed);
                if (executionFailures.length > 0) {
                    throw executionFailures[0].originalException;
                }
            }
            if (!suppressTripwire) {
                for (const result of results) {
                    if (result.tripwireTriggered) {
                        const { GuardrailTripwireTriggered } = await Promise.resolve().then(() => __importStar(require('./exceptions')));
                        throw new GuardrailTripwireTriggered(result);
                    }
                }
            }
            return results;
        }
        catch (error) {
            if (!suppressTripwire &&
                error instanceof Error &&
                error.constructor.name === 'GuardrailTripwireTriggered') {
                throw error;
            }
            throw error;
        }
    }
    createContextWithConversation(conversationHistory) {
        const baseContext = this.context;
        const historySnapshot = conversationHistory.map((entry) => ({ ...entry }));
        const getHistory = () => historySnapshot.map((entry) => ({ ...entry }));
        // Expose conversation_history as both a property and a method for compatibility
        const contextWithHistory = {
            ...baseContext,
            guardrailLlm: baseContext.guardrailLlm,
            conversationHistory: historySnapshot,
            getConversationHistory: getHistory,
        };
        return contextWithHistory;
    }
    appendLlmResponseToConversation(conversationHistory, llmResponse) {
        const normalized = conversationHistory !== null && conversationHistory !== undefined
            ? this.normalizeConversationHistory(conversationHistory)
            : [];
        return (0, conversation_1.appendAssistantResponse)(normalized, llmResponse);
    }
    normalizeConversationHistory(payload) {
        return (0, conversation_1.normalizeConversation)(payload);
    }
    async loadConversationHistoryFromPreviousResponse(previousResponseId) {
        if (!previousResponseId || typeof previousResponseId !== 'string' || previousResponseId.trim() === '') {
            return [];
        }
        const items = await this.collectConversationItems(previousResponseId);
        if (!items || items.length === 0) {
            return [];
        }
        return this.normalizeConversationHistory(items);
    }
    async collectConversationItems(previousResponseId) {
        const items = [];
        const clientRecord = toRecord(this._resourceClient);
        const responsesRecord = getRecord(clientRecord, 'responses');
        const conversationsRecord = getRecord(clientRecord, 'conversations');
        let response;
        const retrieve = getFunction(responsesRecord, 'retrieve');
        if (retrieve) {
            try {
                response = await retrieve(previousResponseId);
            }
            catch {
                return items;
            }
        }
        if (!response) {
            return items;
        }
        const responseRecord = toRecord(response);
        const conversation = responseRecord ? toRecord(responseRecord.conversation) : null;
        const conversationIdValue = conversation?.id;
        const conversationId = typeof conversationIdValue === 'string' ? conversationIdValue : null;
        const conversationItems = conversation ? getRecord(conversationsRecord, 'items') : null;
        const listConversationItems = getFunction(conversationItems, 'list');
        if (conversationId && listConversationItems) {
            try {
                const pageResult = await listConversationItems(conversationId, { order: 'asc', limit: 100 });
                if (isAsyncIterable(pageResult)) {
                    for await (const entry of pageResult) {
                        items.push(entry);
                    }
                }
                else {
                    const resultRecord = toRecord(pageResult);
                    const data = resultRecord?.data;
                    if (Array.isArray(data)) {
                        items.push(...data);
                    }
                }
            }
            catch {
                // Ignore and fall back to input items
            }
        }
        if (items.length === 0) {
            const inputItemsRecord = responsesRecord ? getRecord(responsesRecord, 'inputItems') : null;
            const listInputItems = getFunction(inputItemsRecord, 'list');
            if (listInputItems) {
                try {
                    const pageResult = await listInputItems(previousResponseId, { order: 'asc', limit: 100 });
                    if (isAsyncIterable(pageResult)) {
                        for await (const entry of pageResult) {
                            if (entry != null) {
                                items.push(entry);
                            }
                        }
                    }
                    else {
                        const resultRecord = toRecord(pageResult);
                        const data = resultRecord?.data;
                        if (Array.isArray(data)) {
                            items.push(...data.filter((item) => item != null));
                        }
                    }
                }
                catch {
                    // Ignore, items remain empty
                }
            }
            const outputItems = responseRecord?.output;
            if (Array.isArray(outputItems)) {
                items.push(...outputItems.filter((item) => item != null));
            }
        }
        return items;
    }
    async handleLlmResponse(llmResponse, preflightResults, inputResults, conversationHistory, suppressTripwire = false) {
        const normalizedHistory = conversationHistory !== undefined && conversationHistory !== null
            ? this.normalizeConversationHistory(conversationHistory)
            : [];
        const completeConversation = this.appendLlmResponseToConversation(normalizedHistory, llmResponse);
        const responseText = this.extractResponseText(llmResponse);
        const outputResults = await this.runStageGuardrails('output', responseText, completeConversation, suppressTripwire);
        return this.createGuardrailsResponse(llmResponse, preflightResults, inputResults, outputResults);
    }
}
exports.GuardrailsBaseClient = GuardrailsBaseClient;
//# sourceMappingURL=base-client.js.map